{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "8c1d4bb0",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Starting imports...\n",
      "Importing few...\n",
      "Configuring few...\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "<few.utils.globals.ConfigurationSetter at 0x1553f2eeaa50>"
      ]
     },
     "execution_count": 1,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "print(\"Starting imports...\")\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from numba import cuda, float64, complex128\n",
    "from numba.cuda import jit as cuda_jit\n",
    "import math\n",
    "\n",
    "print(\"Importing few...\")\n",
    "import few\n",
    "\n",
    "from few.trajectory.inspiral import EMRIInspiral\n",
    "from few.trajectory.ode import KerrEccEqFlux\n",
    "from few.amplitude.ampinterp2d import AmpInterpKerrEccEq\n",
    "from few.summation.interpolatedmodesum import InterpolatedModeSum \n",
    "\n",
    "\n",
    "from few.utils.ylm import GetYlms\n",
    "\n",
    "from few import get_file_manager\n",
    "\n",
    "from few.waveform import FastKerrEccentricEquatorialFlux\n",
    "\n",
    "from few.utils.geodesic import get_fundamental_frequencies\n",
    "\n",
    "import os\n",
    "import sys\n",
    "\n",
    "# import gc\n",
    "# import pickle\n",
    "\n",
    "\n",
    "print(\"Configuring few...\")\n",
    "# tune few configuration\n",
    "cfg_set = few.get_config_setter(reset=True)\n",
    "cfg_set.set_log_level(\"info\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "9c835f7b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      " - Backend 'cpu': available\n",
      " - Backend 'cuda11x': unavailable\n",
      " - Backend 'cuda12x': available\n",
      " - Backend 'cuda': available\n",
      " - Backend 'gpu': available\n"
     ]
    }
   ],
   "source": [
    "for backend in [\"cpu\", \"cuda11x\", \"cuda12x\", \"cuda\", \"gpu\"]: \n",
    "    print(f\" - Backend '{backend}': {\"available\" if few.has_backend(backend) else \"unavailable\"}\")  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "85b73795",
   "metadata": {},
   "outputs": [],
   "source": [
    "# GPU configuration and missing variables\n",
    "use_gpu = False\n",
    "dt = 10     # Time step\n",
    "T = 1.0     # Total time\n",
    "\n",
    "# Check GPU availability\n",
    "if not cuda.is_available():\n",
    "    print(\"Warning: CUDA not available, falling back to CPU\")\n",
    "    use_gpu = False"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "111b0aeb",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Setting up waveform generator...\n",
      "Creating FastKerrEccentricEquatorialFlux...\n"
     ]
    }
   ],
   "source": [
    "print(\"Setting up waveform generator...\")\n",
    "# keyword arguments for inspiral generator \n",
    "inspiral_kwargs={\n",
    "        \"func\": 'KerrEccEqFlux',\n",
    "        \"DENSE_STEPPING\": 0, #change to 1/True for uniform sampling\n",
    "        \"include_minus_m\": False, \n",
    "        \"use_gpu\" : use_gpu,\n",
    "        \"force_backend\": \"cuda12x\"  # Force GPU\n",
    "}\n",
    "\n",
    "# keyword arguments for inspiral generator \n",
    "amplitude_kwargs = {\n",
    "    \"force_backend\": \"cuda12x\" # Force GPU\n",
    "    # \"use_gpu\" : use_gpu\n",
    "}\n",
    "\n",
    "# keyword arguments for Ylm generator (GetYlms)\n",
    "Ylm_kwargs = {\n",
    "    \"force_backend\": \"cuda12x\",  # Force GPU\n",
    "    # \"assume_positive_m\": True  # if we assume positive m, it will generate negative m for all m>0\n",
    "}\n",
    "\n",
    "# keyword arguments for summation generator (InterpolatedModeSum)\n",
    "sum_kwargs = {\n",
    "    \"force_backend\": \"cuda12x\",  # Force GPU\n",
    "    \"pad_output\": True,\n",
    "    \"separate_modes\": True\n",
    "    # \"use_gpu\" : use_gpu\n",
    "}\n",
    "\n",
    "print(\"Creating FastKerrEccentricEquatorialFlux...\")\n",
    "# Kerr eccentric flux\n",
    "waveform_gen = FastKerrEccentricEquatorialFlux(\n",
    "    inspiral_kwargs=inspiral_kwargs,\n",
    "    amplitude_kwargs=amplitude_kwargs,\n",
    "    Ylm_kwargs=Ylm_kwargs,\n",
    "    sum_kwargs=sum_kwargs,\n",
    "    use_gpu=use_gpu,\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c1208a5f",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Generating true waveform...\n"
     ]
    }
   ],
   "source": [
    "#Generating data (true)\n",
    "\n",
    "m1_o = 1e6\n",
    "m2_o = 1e1\n",
    "a_o = 0.3\n",
    "p0_o = 12\n",
    "e0_o = 0.1\n",
    "xI_o = 1.0\n",
    "theta_o = np.pi/3  # polar viewing angle\n",
    "phi_o = np.pi/4  # azimuthal viewing angle\n",
    "dist = 1 # Gpc\n",
    "dt = 10\n",
    "\n",
    "print(\"Generating true waveform...\")\n",
    "h_true = waveform_gen(m1_o, m2_o, a_o, p0_o, e0_o, xI_o, theta_o, phi_o, dist=dist, dt=dt, T=1)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5f323db0",
   "metadata": {},
   "outputs": [],
   "source": [
    "print(\"Initializing trajectory and amplitude generators...\")\n",
    "# Initialize trajectory and amplitude generators\n",
    "traj = EMRIInspiral(func=KerrEccEqFlux, force_backend=\"cuda12x\", use_gpu=use_gpu)\n",
    "amp = AmpInterpKerrEccEq(force_backend=\"cuda12x\")\n",
    "interpolate_mode_sum = InterpolatedModeSum(force_backend=\"cuda12x\", pad_output= True, separate_modes=True)\n",
    "ylm_gen = GetYlms(include_minus_m=False, force_backend=\"cuda12x\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5f0467a8",
   "metadata": {},
   "outputs": [],
   "source": [
    "dt"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "361e2fbc",
   "metadata": {},
   "outputs": [],
   "source": [
    "h_true.shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4323143b",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "waveform = interpolate_mode_sum(\n",
    "    t_gpu, teuk_modes_single, ylms_single,\n",
    "    traj.integrator_spline_t, traj.integrator_spline_phase_coeff[:, [0, 2]],\n",
    "    amp.l_arr[[idx]], m_arr, amp.n_arr[[idx]], \n",
    "    dt=dt, T=T\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7811e4d5",
   "metadata": {},
   "outputs": [],
   "source": [
    "def loglike(params):\n",
    "    \"\"\"Log-likelihood function for the nested sampling.\"\"\"\n",
    "    # Convert theta to parameters\n",
    "    m1, m2, a, p0, e0, xI0, theta, phi, dist = params\n",
    "    # print(f\"=== Parameters: m1={m1:.2e}, m2={m2:.2e}, a={a:.3f}, p0={p0:.2f}, e0={e0:.3f}, theta={theta:.3f}, phi={phi:.3f}, dist = {dist:.3f} ===\")\n",
    "\n",
    "    # Generate template waveform with the current parameters\n",
    "    h_temp = waveform_gen(m1, m2, a, p0, e0, xI0, theta, phi, dist=dist, dt=dt, T=T)\n",
    "    # print(f\"h_temp shape: {h_temp.shape}\")\n",
    "    \n",
    "    # Calculate the factor for normalization\n",
    "    factor = gwf.dist_factor(dist, m2)\n",
    "\n",
    "    # Generate trajectory\n",
    "    (t, p, e, x, Phi_phi, Phi_theta, Phi_r) = traj(m1, m2, a, p0, e0, xI0, T=T, dt=dt)\n",
    "    # print(f\"Trajectory length: {len(t)}\")\n",
    "    t_gpu = cp.asarray(t)\n",
    "\n",
    "    # Get amplitudes along trajectory\n",
    "    teuk_modes = amp(a, p, e, x)\n",
    "    # print(f\"teuk_modes shape: {teuk_modes.shape}\")\n",
    "\n",
    "    # Get Ylms\n",
    "    ylms = ylm_gen(amp.unique_l, amp.unique_m, theta, phi).copy()[amp.inverse_lm]\n",
    "\n",
    "    # Calculate power for all modes\n",
    "    m0mask = amp.m_arr_no_mask != 0\n",
    "    total_power = gwf.calc_power(teuk_modes, ylms, m0mask)\n",
    "\n",
    "    # Get mode labels\n",
    "    mode_labels = [f\"({l},{m},{n})\" for l,m,n in zip(amp.l_arr, amp.m_arr, amp.n_arr)]\n",
    "\n",
    "    # Change num of selected modes here \n",
    "    M_mode = 10\n",
    "\n",
    "    # Get top M indices\n",
    "    top_indices_gpu = gwf.xp.argsort(total_power)[-M_mode:][::-1]  # Top M indices in descending order\n",
    "    top_indices = top_indices_gpu.get().tolist()  # Convert to CPU list only once\n",
    "\n",
    "    # Pick modes based on top M power contributions\n",
    "    mp_modes = [mode_labels[idx] for idx in top_indices]\n",
    "    top_indices = [mode_labels.index(mode) for mode in mp_modes]\n",
    "\n",
    "    # Generate hm_arr for top modes\n",
    "    waveform_per_mode = []\n",
    "    for idx in top_indices:\n",
    "        l = amp.l_arr[idx]\n",
    "        m = amp.m_arr[idx]\n",
    "        n = amp.n_arr[idx]\n",
    "\n",
    "        if m >= 0:\n",
    "            teuk_modes_single = teuk_modes[:, [idx]]\n",
    "            ylms_single = ylms[[idx]]\n",
    "            m_arr = amp.m_arr[[idx]]\n",
    "        else:\n",
    "            pos_m_mask = (amp.l_arr == l) & (amp.m_arr == -m) & (amp.n_arr == n)\n",
    "            pos_m_idx = gwf.xp.where(pos_m_mask)[0][0]\n",
    "            teuk_modes_single = (-1)**l * gwf.xp.conj(teuk_modes[:, [pos_m_idx]])\n",
    "            ylms_single = ylms[[idx]]\n",
    "            m_arr = gwf.xp.abs(amp.m_arr[[idx]]) \n",
    "\n",
    "        waveform = interpolate_mode_sum(\n",
    "            t_gpu, teuk_modes_single, ylms_single,\n",
    "            traj.integrator_spline_t, traj.integrator_spline_phase_coeff[:, [0, 2]],\n",
    "            amp.l_arr[[idx]], m_arr, amp.n_arr[[idx]], \n",
    "            dt=dt, T=T\n",
    "        )\n",
    "        waveform_per_mode.append(waveform / factor)\n",
    "\n",
    "    # Calculate rho_m\n",
    "    rho_m = gwf.rhostat_modes(waveform_per_mode)\n",
    "    # print(f\"rho_m: {rho_m}\")\n",
    "    \n",
    "    # Calculate Xm \n",
    "    X_modes = gwf.Xmstat(h_true, waveform_per_mode, rho_m)\n",
    "    # print(f\"X_modes: {X_modes}\")\n",
    "\n",
    "    # Calculate X_scalar\n",
    "    Xdotrho = gwf.xp.sum(X_modes * rho_m)\n",
    "    rho_norm = gwf.xp.sqrt(gwf.xp.sum(rho_m**2))\n",
    "    X_scalar = Xdotrho / rho_norm\n",
    "    # print(f\"X_scalar: {X_scalar:.4f}\")\n",
    "\n",
    "    X_check = gwf.Xstat(h_true, h_temp)\n",
    "    # print(f\"X_check: {X_check:.4f}\")\n",
    "\n",
    "    # Calculate optimal SNR of most dominant mode by power\n",
    "    rho_dom_M = gwf.rhostat(waveform_per_mode[0])\n",
    "\n",
    "    # Calculate total rho \n",
    "    rho_tot = gwf.rhostat(h_temp)\n",
    "\n",
    "    # Calculate alpha with numerical stability\n",
    "    alpha = rho_dom_M / rho_tot  \n",
    "    # print(f\"alpha: {alpha:.4f}\")\n",
    "\n",
    "    # Calculate beta with numerical checks\n",
    "    beta_num = 2 * gwf.xp.log(alpha * rho_tot)\n",
    "    beta_denom = (1-alpha**2) * rho_tot**2 \n",
    "\n",
    "    beta = beta_num / beta_denom\n",
    "    # print(f\"beta: {beta:.4f}\")\n",
    "\n",
    "    # Calculate chi sq\n",
    "    chi_sq = gwf.chi_sq(X_modes, rho_m)\n",
    "    # print(f\"chi_sq: {chi_sq:.4f}\")\n",
    "\n",
    "    # Calculate f statistic \n",
    "    f_exp = -0.5 * beta * chi_sq \n",
    "\n",
    "    # Overflow protection for large exponentials \n",
    "    # TODO: Check for alternate ways that are more accurate? mpmath? logsumexp trick?\n",
    "    if f_exp > 700:  \n",
    "        f_exp = 700 # Cap \n",
    "    elif f_exp < -700:\n",
    "        return -np.inf  \n",
    "    \n",
    "    f_stat = X_scalar * gwf.xp.exp(f_exp)\n",
    "\n",
    "    logl_res = float(gwf.xp.real(f_stat).get())\n",
    "    \n",
    "    # Check for NaNs \n",
    "    if np.isnan(logl_res):\n",
    "        return -np.inf\n",
    "\n",
    "    return logl_res \n",
    "\n",
    "\n",
    "\n",
    "# Parameter space search example\n",
    "def parameter_space_search_example(n_samples=10):\n",
    "    \"\"\"Example parameter space search\"\"\"\n",
    "    print(f\"Running parameter space search with {n_samples} samples...\")\n",
    "    \n",
    "    # Parameter ranges (adjust as needed)\n",
    "    m1_range = (1e5, 1e7)\n",
    "    m2_range = (1, 100)  \n",
    "    a_range = (0, 1)\n",
    "    p0_range = (10, 100)\n",
    "    e0_range = (0.01, 0.7)\n",
    "    xI0_range = (1.0, 1.0) # keeping it equatorial for now\n",
    "    theta_range = (0, np.pi)\n",
    "    phi_range = (0, 2*np.pi)\n",
    "    dist_range = (0.01, 100)  \n",
    "    \n",
    "    # Generate random parameter samples\n",
    "    np.random.seed(7)  # For reproducibility\n",
    "    \n",
    "    for i in range(n_samples):\n",
    "        # Sample masses log-uniformly, others  uniformly\n",
    "        m1 = 10**(np.random.uniform(np.log10(m1_range[0]), np.log10(m1_range[1])))\n",
    "        m2 = 10**(np.random.uniform(np.log10(m2_range[0]), np.log10(m2_range[1])))\n",
    "        params = [\n",
    "            m1,\n",
    "            m2, \n",
    "            np.random.uniform(*a_range),\n",
    "            np.random.uniform(*p0_range),\n",
    "            np.random.uniform(*e0_range),\n",
    "            np.random.uniform(*xI0_range),\n",
    "            np.random.uniform(*theta_range),\n",
    "            np.random.uniform(*phi_range),\n",
    "            np.random.uniform(*dist_range)\n",
    "        ]\n",
    "        \n",
    "        try:\n",
    "            # Evaluate likelihood\n",
    "            f_stat = loglike(params)\n",
    "            print(f\"Sample {i+1}/{n_samples}: f_stat = {f_stat}\")\n",
    "                \n",
    "        except Exception as e:\n",
    "            print(f\"Error in evaluation {i+1}: {e}\")\n",
    "            continue\n",
    "    \n",
    "    print(\"Parameter space search completed!\")"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "few_sm",
   "language": "python",
   "name": "few_sm"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
